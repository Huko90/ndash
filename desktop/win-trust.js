const fs = require('fs');
const path = require('path');
const crypto = require('crypto');
const { execFile } = require('child_process');

// --- Pure helpers ---

/**
 * Compute SHA-1 thumbprint from a PEM certificate file.
 * Matches the thumbprint shown in Windows certmgr.msc.
 */
function computeThumbprint(certPath) {
  const pem = fs.readFileSync(certPath, 'utf8');
  const b64 = pem.replace(/-----[^-]+-----/g, '').replace(/\s+/g, '');
  const der = Buffer.from(b64, 'base64');
  return crypto.createHash('sha1').update(der).digest('hex').toUpperCase();
}

/**
 * Escape a string for embedding inside a PowerShell single-quoted string.
 * In PS single-quoted strings, the only escape is '' for a literal '.
 */
function psEscape(str) {
  return String(str).replace(/'/g, "''");
}

/**
 * Run a PowerShell command (unelevated) and return stdout.
 */
function psRun(command, timeoutMs) {
  return new Promise(function(resolve, reject) {
    execFile('powershell.exe', [
      '-ExecutionPolicy', 'Bypass',
      '-NoProfile',
      '-NoLogo',
      '-Command', command
    ], { timeout: timeoutMs || 15000 }, function(err, stdout) {
      if (err) return reject(err);
      resolve((stdout || '').trim());
    });
  });
}

// --- Pre-flight checks (unelevated) ---

/**
 * Check if a certificate with the given thumbprint is in CurrentUser\Root.
 */
function isCertTrusted(thumbprint) {
  if (process.platform !== 'win32') return Promise.resolve(false);
  var cmd = "if (Get-ChildItem Cert:\\CurrentUser\\Root | Where-Object { $_.Thumbprint -eq '" +
    psEscape(thumbprint) + "' }) { Write-Output 'YES' } else { Write-Output 'NO' }";
  return psRun(cmd).then(function(out) {
    return out.indexOf('YES') !== -1;
  }).catch(function() {
    return false;
  });
}

/**
 * Check firewall rules by display name AND verify port/protocol/direction/action/enabled.
 * Returns { name: {exists, valid, details} } map.
 */
function checkFirewallRules(rules) {
  if (process.platform !== 'win32') return Promise.resolve({});
  // rules: [{name, port, protocol}]
  var checks = rules.map(function(r) {
    return "'" + psEscape(r.name) + "'";
  }).join(',');

  var cmd = [
    '$names = @(' + checks + ')',
    '$result = @{}',
    'foreach ($name in $names) {',
    '  $rule = Get-NetFirewallRule -DisplayName $name -ErrorAction SilentlyContinue',
    '  if ($rule) {',
    '    $portFilter = $rule | Get-NetFirewallPortFilter',
    '    $result[$name] = @{',
    '      Exists = $true',
    '      Enabled = $rule.Enabled.ToString()',
    '      Direction = $rule.Direction.ToString()',
    '      Action = $rule.Action.ToString()',
    '      Profile = $rule.Profile.ToString()',
    '      LocalPort = $portFilter.LocalPort',
    '      Protocol = $portFilter.Protocol',
    '    }',
    '  } else {',
    '    $result[$name] = @{ Exists = $false }',
    '  }',
    '}',
    '$result | ConvertTo-Json -Depth 3'
  ].join('\n');

  return psRun(cmd, 20000).then(function(out) {
    if (!out) return {};
    try {
      var parsed = JSON.parse(out);
      var result = {};
      rules.forEach(function(r) {
        var entry = parsed[r.name];
        if (!entry || !entry.Exists) {
          result[r.name] = { exists: false, valid: false };
          return;
        }
        var valid = entry.Enabled === 'True' &&
          entry.Direction === 'Inbound' &&
          entry.Action === 'Allow' &&
          String(entry.LocalPort) === String(r.port) &&
          entry.Protocol === r.protocol;
        result[r.name] = { exists: true, valid: valid, details: entry };
      });
      return result;
    } catch (e) {
      return {};
    }
  }).catch(function() {
    return {};
  });
}

// --- Elevation script generation ---

/**
 * Build a PowerShell script for elevated execution (firewall rules only).
 * Cert is installed unelevated via installCertUnelevated().
 */
function buildFirewallScript(opts) {
  var lines = [
    '# Generated by nDash — do not edit',
    'Set-StrictMode -Version Latest',
    '$ErrorActionPreference = "Stop"',
    '$result = @{ ok = $true; firewallRules = @(); error = "" }',
    '',
    'try {'
  ];

  // Remove old rules if ports changed
  if (opts.removeFirewallRules && opts.removeFirewallRules.length) {
    opts.removeFirewallRules.forEach(function(name) {
      lines.push("  $old = Get-NetFirewallRule -DisplayName '" + psEscape(name) + "' -ErrorAction SilentlyContinue");
      lines.push("  if ($old) { Remove-NetFirewallRule -DisplayName '" + psEscape(name) + "' }");
    });
    lines.push('');
  }

  // Create new firewall rules
  if (opts.firewallRules && opts.firewallRules.length) {
    opts.firewallRules.forEach(function(r) {
      lines.push("  # Remove existing rule with same name to avoid duplicates");
      lines.push("  $existing = Get-NetFirewallRule -DisplayName '" + psEscape(r.name) + "' -ErrorAction SilentlyContinue");
      lines.push("  if ($existing) { Remove-NetFirewallRule -DisplayName '" + psEscape(r.name) + "' }");
      lines.push("  New-NetFirewallRule -DisplayName '" + psEscape(r.name) +
        "' -Direction Inbound -Action Allow -Protocol " + psEscape(r.protocol) +
        " -LocalPort " + String(parseInt(r.port, 10)) +
        " -Profile Private | Out-Null");
      lines.push("  $result.firewallRules += '" + psEscape(r.name) + "'");
      lines.push('');
    });
  }

  lines.push('} catch {');
  lines.push('  $result.ok = $false');
  lines.push('  $result.error = $_.Exception.Message');
  lines.push('}');
  lines.push('');
  lines.push("$result | ConvertTo-Json -Depth 2 | Out-File -FilePath '" +
    psEscape(opts.resultPath) + "' -Encoding utf8");

  return lines.join('\r\n');
}

/**
 * Install certificate into CurrentUser\Root unelevated.
 * This does NOT require admin rights and runs as the current user,
 * avoiding the wrong-user problem with UAC elevation.
 */
function installCertUnelevated(certPath) {
  if (process.platform !== 'win32') {
    return Promise.resolve({ ok: false, error: 'Windows only' });
  }
  var cmd = "Import-Certificate -FilePath '" + psEscape(certPath) +
    "' -CertStoreLocation Cert:\\CurrentUser\\Root | Out-Null; Write-Output 'OK'";
  return psRun(cmd, 15000).then(function(out) {
    return { ok: out.indexOf('OK') !== -1 };
  }).catch(function(err) {
    return { ok: false, error: (err && err.message) || 'Cert import failed' };
  });
}

/**
 * Remove a certificate from CurrentUser\Root by thumbprint (unelevated).
 */
function removeCertUnelevated(thumbprint) {
  if (process.platform !== 'win32') return Promise.resolve({ ok: true });
  var cmd = "$cert = Get-ChildItem Cert:\\CurrentUser\\Root | Where-Object { $_.Thumbprint -eq '" +
    psEscape(thumbprint) + "' }; if ($cert) { Remove-Item -Path $cert.PSPath -Force }; Write-Output 'OK'";
  return psRun(cmd, 15000).then(function() {
    return { ok: true };
  }).catch(function(err) {
    return { ok: false, error: (err && err.message) || 'Cert removal failed' };
  });
}

// --- Elevated execution ---

/**
 * Run a PowerShell script elevated via Start-Process -Verb RunAs.
 * Returns parsed JSON result from the result file.
 */
function runElevated(scriptPath, resultPath) {
  return new Promise(function(resolve) {
    // Delete stale result file
    try { fs.unlinkSync(resultPath); } catch (_) {}

    // Outer unelevated powershell spawns elevated powershell
    var args = [
      '-ExecutionPolicy', 'Bypass',
      '-NoProfile',
      '-NoLogo',
      '-Command',
      "Start-Process powershell.exe -ArgumentList '-ExecutionPolicy Bypass -NoProfile -File \"" +
        psEscape(scriptPath).replace(/"/g, '`"') + "\"' -Verb RunAs -Wait"
    ];

    execFile('powershell.exe', args, { timeout: 120000 }, function(err) {
      // Clean up script file
      try { fs.unlinkSync(scriptPath); } catch (_) {}

      if (err) {
        resolve({ ok: false, firewallRules: [], error: err.message || 'Elevation cancelled or failed' });
        return;
      }

      try {
        var raw = fs.readFileSync(resultPath, 'utf8');
        // Remove BOM that PowerShell UTF-8 can add
        var cleaned = raw.replace(/^\uFEFF/, '');
        var result = JSON.parse(cleaned);
        resolve(result);
      } catch (parseErr) {
        resolve({ ok: false, firewallRules: [], error: 'Could not read elevation result' });
      } finally {
        try { fs.unlinkSync(resultPath); } catch (_) {}
      }
    });
  });
}

// --- Main entry points ---

/**
 * Install trust: cert (unelevated) + firewall (elevated).
 * Skips steps that are already done. Returns result object.
 */
function installTrust(opts) {
  if (process.platform !== 'win32') {
    return Promise.resolve({ ok: false, error: 'Windows only', supported: false });
  }

  var certPath = opts.certPath;
  var httpPort = opts.httpPort;
  var httpsPort = opts.httpsPort;
  var userDataPath = opts.userDataPath;
  var currentTrustState = opts.currentTrustState || {};

  var thumbprint = computeThumbprint(certPath);

  var desiredRules = [
    { name: 'nDash HTTP ' + httpPort, port: httpPort, protocol: 'TCP' },
    { name: 'nDash HTTPS ' + httpsPort, port: httpsPort, protocol: 'TCP' }
  ];

  var result = {
    ok: true,
    thumbprint: thumbprint,
    certInstalled: false,
    firewallRules: [],
    skippedCert: false,
    skippedFirewall: false,
    error: ''
  };

  return isCertTrusted(thumbprint).then(function(certAlreadyTrusted) {
    if (certAlreadyTrusted) {
      result.skippedCert = true;
    } else {
      // Remove old cert if thumbprint changed
      var oldThumb = currentTrustState.thumbprint || '';
      var removeOldCert = oldThumb && oldThumb !== thumbprint
        ? removeCertUnelevated(oldThumb)
        : Promise.resolve({ ok: true });

      return removeOldCert.then(function() {
        return installCertUnelevated(certPath);
      }).then(function(certResult) {
        if (!certResult.ok) {
          result.ok = false;
          result.error = certResult.error || 'Certificate installation failed';
          return result;
        }
        result.certInstalled = true;
      });
    }
  }).then(function() {
    if (!result.ok) return result;

    return checkFirewallRules(desiredRules).then(function(existingRules) {
      var allValid = desiredRules.every(function(r) {
        var entry = existingRules[r.name];
        return entry && entry.valid;
      });

      if (allValid) {
        result.skippedFirewall = true;
        result.firewallRules = desiredRules.map(function(r) { return r.name; });
        writeTrustStateFile(userDataPath, {
          thumbprint: thumbprint,
          firewallRuleNames: desiredRules.map(function(r) { return r.name; }),
          installedAt: Date.now()
        });
        return result;
      }

      // Determine old rules to remove (from previous ports)
      var oldRuleNames = (currentTrustState.firewallRuleNames || []).filter(function(name) {
        return !desiredRules.some(function(r) { return r.name === name; });
      });

      // Only create rules that don't exist or aren't valid
      var rulesToCreate = desiredRules.filter(function(r) {
        var entry = existingRules[r.name];
        return !entry || !entry.valid;
      });

      var scriptPath = path.join(userDataPath, 'ndash-elevate.ps1');
      var resultPath = path.join(userDataPath, 'ndash-elevate-result.json');

      var scriptContent = buildFirewallScript({
        firewallRules: rulesToCreate,
        removeFirewallRules: oldRuleNames,
        resultPath: resultPath
      });

      fs.writeFileSync(scriptPath, scriptContent, 'utf8');

      return runElevated(scriptPath, resultPath).then(function(elevResult) {
        if (elevResult.ok) {
          result.firewallRules = desiredRules.map(function(r) { return r.name; });
          writeTrustStateFile(userDataPath, {
            thumbprint: thumbprint,
            firewallRuleNames: result.firewallRules,
            installedAt: Date.now()
          });
        } else {
          result.ok = false;
          result.error = elevResult.error || 'Firewall setup failed or was cancelled';
          // Cert was still installed successfully — partial success
          result.firewallRules = elevResult.firewallRules || [];
        }
        return result;
      });
    });
  }).catch(function(err) {
    result.ok = false;
    result.error = (err && err.message) || 'Trust installation failed';
    return result;
  });
}

/**
 * Write trust state to a well-known file readable by the NSIS uninstaller.
 */
function writeTrustStateFile(userDataPath, state) {
  var filePath = path.join(userDataPath, 'ndash-trust-state.json');
  try {
    fs.mkdirSync(path.dirname(filePath), { recursive: true });
    fs.writeFileSync(filePath, JSON.stringify(state, null, 2), 'utf8');
  } catch (_) {}
}

module.exports = {
  computeThumbprint: computeThumbprint,
  psEscape: psEscape,
  isCertTrusted: isCertTrusted,
  checkFirewallRules: checkFirewallRules,
  buildFirewallScript: buildFirewallScript,
  installCertUnelevated: installCertUnelevated,
  removeCertUnelevated: removeCertUnelevated,
  runElevated: runElevated,
  installTrust: installTrust,
  writeTrustStateFile: writeTrustStateFile
};
